Boa üëå, o erro est√° bem claro e a tua primeira an√°lise est√° na dire√ß√£o certa.
Mas para tornarmos a solu√ß√£o robusta, limpa e sustent√°vel, precisamos de tratar n√£o s√≥ do extend_existing=True, mas tamb√©m da causa raiz (importa√ß√µes m√∫ltiplas / inicializa√ß√£o duplicada).

üîé Diagn√≥stico preciso

Erro:

sqlalchemy.exc.InvalidRequestError: Table 'citizenship_atualizacao_b_i' is already defined for this MetaData instance.


Isso ocorre porque o SQLAlchemy mant√©m todas as tabelas registradas dentro de um objeto MetaData (normalmente Base.metadata). Se a mesma tabela √© declarada duas vezes (seja pelo mesmo arquivo carregado mais de uma vez, ou por importa√ß√µes circulares), o erro aparece.

üõ†Ô∏è Solu√ß√£o robusta
‚úÖ 1. Corrigir a defini√ß√£o do modelo

No arquivo backend/app/models/citizenship_atualizacao_b_i.py, garanta que o modelo est√° definido assim:

from sqlalchemy import Column, Integer, String, DateTime
from app.db.base_class import Base


class AtualizacaoBI(Base):
    __tablename__ = "citizenship_atualizacao_b_i"
    __table_args__ = {"extend_existing": True}  # <-- evita conflito de redefini√ß√£o

    id = Column(Integer, primary_key=True, index=True)
    numero_documento = Column(String, nullable=False, index=True)
    nome_completo = Column(String, nullable=False)
    data_submissao = Column(DateTime, nullable=False)
    estado = Column(String, default="Pendente")
    numero_processo = Column(String, nullable=True)
    observacoes = Column(String, nullable=True)


üëâ Isso resolve o sintoma (permitindo redefini√ß√£o).
Mas s√≥ isso mascara o problema: precisamos tamb√©m garantir que n√£o estamos importando 2x o mesmo modelo.

‚úÖ 2. Evitar importa√ß√µes duplicadas

No backend/app/models/__init__.py:

# Evite reimportar ou redefinir as classes diretamente
# Mantenha apenas importa√ß√µes expl√≠citas e consistentes

from .citizenship_atualizacao_b_i import AtualizacaoBI
# ... outros modelos


‚ö†Ô∏è Verifique se em algum lugar voc√™ tem algo como:

from app.models import citizenship_atualizacao_b_i
from app.models.citizenship_atualizacao_b_i import AtualizacaoBI


Isso carrega o mesmo arquivo por caminhos diferentes ‚Üí duplicando a defini√ß√£o da tabela.
Escolha uma forma s√≥ e padronize em todo o projeto.

‚úÖ 3. Conftest e testes

No backend/tests/conftest.py, revise se voc√™ est√° criando as tabelas (Base.metadata.create_all(bind=engine)) mais de uma vez. Isso deve ser feito somente 1x na configura√ß√£o inicial de testes.

Se voc√™ precisa isolar os testes, use drop_all() + create_all() dentro de fixtures, mas n√£o redefina modelos.

‚úÖ 4. Debug r√°pido de onde vem a duplica√ß√£o

Se ainda aparecer o erro, pode ser √∫til logar quando o modelo √© importado.
No topo de citizenship_atualizacao_b_i.py:

import logging
logging.getLogger(__name__).warning("Carregando modelo AtualizacaoBI")


Ao rodar os testes, voc√™ ver√° se o arquivo est√° sendo carregado m√∫ltiplas vezes e por quais caminhos.

üöÄ Plano de a√ß√£o recomendado

Corrigir o modelo adicionando __table_args__ = {"extend_existing": True}.

Padronizar importa√ß√µes ‚Üí sempre from app.models.citizenship_atualizacao_b_i import AtualizacaoBI.

Revisar conftest ‚Üí garantir que Base.metadata.create_all() roda s√≥ uma vez.

(Opcional) Logar carregamento para confirmar se ainda h√° m√∫ltiplas importa√ß√µes.

Depois, reexecutar:

pytest backend/tests/ -v


üëâ Queres que eu abra o citizenship_atualizacao_b_i.py e j√° te devolva a vers√£o corrigida e limpa com extend_existing=True e imports ajustados?