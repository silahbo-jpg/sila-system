# Convertido de migrate_to_postgres.sh por convert_shell_to_powershell.ps1\n\n<#\nEste script foi convertido automaticamente de um script shell (.sh) para PowerShell (.ps1).\nAlgumas conversões comuns foram aplicadas, mas é provável que seja necessário ajuste manual.\n\nConversões aplicadas automaticamente:\n- Comentários (# -> #)\n- Variáveis básicas ( -> \)\n\nVerifique e ajuste manualmente:\n- Comandos específicos do Linux (ls, grep, etc.) para equivalentes do PowerShell\n- Redirecionamentos de saída (>, >>, |)\n- Estruturas de controle (if, for, while)\n- Execução de comandos em sequência (;, &&, ||)\n#>\n\n# #!/bin/bash\n\n# Script de migração e padronização do projeto SILA\n# Este script deve ser executado no terminal WSL (Ubuntu)\n\nset -e  # Interrompe o script se algum comando falhar\n\nWrite-Host "===== Iniciando processo de padronização e migração para PostgreSQL ====="\nWrite-Host ""\n\n# Diretório base do projeto\nBASE_DIR="$HOME/SGI/sila/sila-system"\ncd "$BASE_DIR"\n\nWrite-Host "===== 1. Padronizando nomenclatura e estrutura ====="\n\n# 1.1 Verificar e padronizar requirements_test.txt\nif [ -f "backend/requirements-test.txt" ] && [ ! -f "backend/requirements_test.txt" ]; then\nWrite-Host "Renomeando requirements-test.txt para requirements_test.txt..."\n    mv backend/requirements-test.txt backend/requirements_test.txt\nelif [ -f "backend/requirements-test.txt" ] && [ -f "backend/requirements_test.txt" ]; then\nWrite-Host "Ambos os arquivos requirements-test.txt e requirements_test.txt existem."\nWrite-Host "Verificando diferenças..."\n    diff -u backend/requirements-test.txt backend/requirements_test.txt || true\nWrite-Host "Mantendo requirements_test.txt e removendo requirements-test.txt..."\n    rm backend/requirements-test.txt\nfi\n\n# 1.2 Verificar e padronizar pytest.ini\nif [ -f "backend/pytest.inies" ] && [ -f "backend/pytest.ini" ]; then\nWrite-Host "Ambos os arquivos pytest.ini e pytest.inies existem."\nWrite-Host "Verificando diferenças..."\n    diff -u backend/pytest.ini backend/pytest.inies || true\nWrite-Host "Mantendo pytest.ini e removendo pytest.inies..."\n    rm backend/pytest.inies\nelif [ -f "backend/pytest.inies" ] && [ ! -f "backend/pytest.ini" ]; then\nWrite-Host "Renomeando pytest.inies para pytest.ini..."\n    mv backend/pytest.inies backend/pytest.ini\nfi\n\n# 1.3 Atualizar requirements_test.txt para incluir pytest-cov\nif [ -f "backend/requirements_test.txt" ]; then\nWrite-Host "Atualizando requirements_test.txt para incluir pytest-cov..."\n    if ! grep -q "pytest-cov" backend/requirements_test.txt; then\nWrite-Host "pytest-cov==4.1.0" >> backend/requirements_test.txt\nWrite-Host "Adicionado pytest-cov==4.1.0 ao requirements_test.txt"\n    else\nWrite-Host "pytest-cov já está incluído em requirements_test.txt"\n    fi\nfi\n\nWrite-Host ""\nWrite-Host "===== 2. Configurando conexão com PostgreSQL ====="\n\n# 2.1 Criar diretório db se não existir\nNew-Item -Path backend/app/core/db -ItemType Directory -Force | Out-Null\n\n# 2.2 Criar arquivo db.py\nWrite-Host "Criando arquivo db.py..."\n# TODO: Converter comando Linux: cat > backend/app/core/db/db.py << 'EOF'\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nDATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./sila.db")\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\nEOF\n\n# 2.3 Criar arquivo __init__.py no diretório db\ntouch backend/app/core/db/__init__.py\n\n# 2.4 Criar/atualizar arquivo .env\nWrite-Host "Criando/atualizando arquivo .env..."\nif [ ! -f "backend/.env" ]; then\n    cp backend/.env.example backend/.env 2>/dev/null || touch backend/.env\nfi\n\nWrite-Host "Configurando DATABASE_URL no .env..."\nif grep -q "DATABASE_URL" backend/.env; then\n    # Substituir a linha existente\n# TODO: Converter comando Linux:     sed -i 's|^DATABASE_URL=.*$|DATABASE_URL=postgresql://postgres:postgres@localhost:5432/sila_dev|g' backend/.env\nelse\n    # Adicionar nova linha\nWrite-Host "DATABASE_URL=postgresql://postgres:postgres@localhost:5432/sila_dev" >> backend/.env\nfi\n\n# 2.5 Atualizar requirements.txt para incluir psycopg2-binary\nWrite-Host "Atualizando requirements.txt para incluir psycopg2-binary..."\nif ! grep -q "psycopg2-binary" backend/requirements.txt; then\nWrite-Host "psycopg2-binary==2.9.5" >> backend/requirements.txt\nWrite-Host "Adicionado psycopg2-binary==2.9.5 ao requirements.txt"\nelse\nWrite-Host "psycopg2-binary já está incluído em requirements.txt"\nfi\n\n# 2.6 Verificar se alembic está instalado\nif ! grep -q "alembic" backend/requirements.txt; then\nWrite-Host "alembic==1.8.1" >> backend/requirements.txt\nWrite-Host "Adicionado alembic==1.8.1 ao requirements.txt"\nelse\nWrite-Host "alembic já está incluído em requirements.txt"\nfi\n\nWrite-Host ""\nWrite-Host "===== 3. Buscando modelos que precisam ser atualizados ====="\n\n# 3.1 Encontrar arquivos que usam declarative_base()\nWrite-Host "Procurando por arquivos que usam declarative_base()..."\n# TODO: Converter comando Linux: GREP_RESULT=$(grep -r "declarative_base()" backend/app/models/ 2>/dev/null || echo "Nenhum arquivo encontrado")\nWrite-Host "$GREP_RESULT"\n\n# 3.2 Criar script para atualizar modelos\nWrite-Host "Criando script para atualizar modelos..."\n# TODO: Converter comando Linux: cat > update_models.py << 'EOF'\nimport os\nimport re\n\ndef update_model_file(file_path):\n    with open(file_path, 'r') as file:\n        content = file.read()\n    \n    # Verificar se o arquivo já importa Base de app.core.db.db\n    if "from app.core.db.db import Base" in content:\n        print(f"Arquivo {file_path} já importa Base corretamente.")\n        return False\n    \n    # Substituir importação de declarative_base\n    content = re.sub(\n        r'from sqlalchemy\.ext\.declarative import declarative_base',\n        'from app.core.db.db import Base',\n        content\n    )\n    \n    # Remover definição de Base = declarative_base()\n    content = re.sub(r'\nBase = declarative_base\(\)\n', '\n', content)\n    \n    with open(file_path, 'w') as file:\n        file.write(content)\n    \n    print(f"Atualizado: {file_path}")\n    return True\n\ndef find_and_update_models():\n    models_dir = 'backend/app/models'\n    updated_files = 0\n    \n    for root, _, files in os.walk(models_dir):\n        for file in files:\n            if file.endswith('.py'):\n                file_path = os.path.join(root, file)\n                with open(file_path, 'r') as f:\n                    content = f.read()\n                    if 'declarative_base()' in content:\n                        if update_model_file(file_path):\n                            updated_files += 1\n    \n    return updated_files\n\nif __name__ == "__main__":\n    print("Atualizando modelos para usar Base de app.core.db.db...")\n    updated = find_and_update_models()\n    print(f"Total de {updated} arquivos atualizados.")\nEOF\n\n# Executar script para atualizar modelos\npython update_models.py\n\nWrite-Host ""\nWrite-Host "===== 4. Configurando testes com cobertura ====="\n\n# 4.1 Atualizar .coveragerc\nWrite-Host "Atualizando .coveragerc..."\n# TODO: Converter comando Linux: cat > backend/.coveragerc << 'EOF'\n[run]\nsource = app\nomit = \n    app/tests/*\n    app/*/__init__.py\n\n[report]\nexclude_lines =\n    pragma: no cover\n    def __repr__\n    raise NotImplementedError\n    if __name__ == .__main__.:\n    pass\n    raise ImportError\nEOF\n\n# 4.2 Criar script para executar testes com cobertura\nWrite-Host "Criando script para executar testes com cobertura..."\nNew-Item -Path backend/scripts -ItemType Directory -Force | Out-Null\n# TODO: Converter comando Linux: cat > backend/scripts/run_tests_with_coverage.sh << 'EOF'\n# #!/bin/bash\ncd "$(dirname "$0")"/.. || exit\n\n# Executar testes com cobertura\npython -m pytest --cov=app --cov-report=term --cov-report=html:coverage_html\n\n# Exibir resumo da cobertura\nWrite-Host "\nResumo da cobertura de testes:\n"\n# TODO: Converter comando Linux: cat .coverage | grep -v "pragma: no cover" | wc -l\n\n# Abrir relatório HTML se disponível\nif command -v xdg-open > /dev/null; then\n  xdg-open coverage_html/index.html &\nfi\nEOF\n\n# Tornar o script executável\n# TODO: Converter comando Linux: chmod +x backend/scripts/run_tests_with_coverage.sh\n\nWrite-Host ""\nWrite-Host "===== 5. Criando script de migração de SQLite para PostgreSQL ====="\n\n# 5.1 Criar script de migração\nNew-Item -Path scripts -ItemType Directory -Force | Out-Null\n# TODO: Converter comando Linux: cat > scripts/migrate_sqlite_to_postgres.py << 'EOF'\nimport os\nimport sys\nimport sqlite3\nimport psycopg2\nfrom psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT\nfrom dotenv import load_dotenv\n\n# Carregar variáveis de ambiente\nload_dotenv("backend/.env")\n\n# Configurações\nSQLITE_DB_PATH = "backend/sila.db"\nPG_CONNECTION = os.getenv("DATABASE_URL", "postgresql://postgres:postgres@localhost:5432/sila_dev")\n\n# Extrair componentes da string de conexão PostgreSQL\ndb_parts = PG_CONNECTION.replace("postgresql://", "").split("/")\ndb_name = db_parts[1] if len(db_parts) > 1 else "sila"\ndb_conn = db_parts[0].split("@")\ndb_user_pass = db_conn[0].split(":")\ndb_user = db_user_pass[0]\ndb_pass = db_user_pass[1] if len(db_user_pass) > 1 else ""\ndb_host_port = db_conn[1].split(":")\ndb_host = db_host_port[0]\ndb_port = db_host_port[1] if len(db_host_port) > 1 else "5432"\n\ndef create_postgres_db():\n    """Cria o banco de dados PostgreSQL se não existir"""\n    try:\n        # Conectar ao PostgreSQL sem especificar um banco de dados\n        conn = psycopg2.connect(\n            user=db_user,\n            password=db_pass,\n            host=db_host,\n            port=db_port\n        )\n        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)\n        cursor = conn.cursor()\n        \n        # Verificar se o banco de dados já existe\n        cursor.execute(f"SELECT 1 FROM pg_database WHERE datname = '{db_name}'")\n        exists = cursor.fetchone()\n        \n        if not exists:\n            print(f"Criando banco de dados '{db_name}'...")\n            cursor.execute(f"CREATE DATABASE {db_name}")\n            print(f"Banco de dados '{db_name}' criado com sucesso!")\n        else:\n            print(f"Banco de dados '{db_name}' já existe.")\n            \n        cursor.close()\n        conn.close()\n        return True\n    except Exception as e:\n        print(f"Erro ao criar banco de dados PostgreSQL: {e}")\n        return False\n\ndef get_sqlite_tables():\n    """Obtém a lista de tabelas do SQLite"""\n    try:\n        conn = sqlite3.connect(SQLITE_DB_PATH)\n        cursor = conn.cursor()\n        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")\n        tables = [row[0] for row in cursor.fetchall()]\n        cursor.close()\n        conn.close()\n        return tables\n    except Exception as e:\n        print(f"Erro ao obter tabelas do SQLite: {e}")\n        return []\n\ndef get_table_schema(table_name):\n    """Obtém o esquema de uma tabela SQLite"""\n    try:\n        conn = sqlite3.connect(SQLITE_DB_PATH)\n        cursor = conn.cursor()\n        cursor.execute(f"PRAGMA table_info({table_name})")\n        columns = cursor.fetchall()\n        schema = []\n        \n        for col in columns:\n            col_id, col_name, col_type, not_null, default_val, is_pk = col\n            # Mapear tipos SQLite para PostgreSQL\n            pg_type = map_sqlite_to_pg_type(col_type)\n            constraints = []\n            \n            if is_pk:\n                constraints.append("PRIMARY KEY")\n            if not_null:\n                constraints.append("NOT NULL")\n            if default_val is not None:\n                if default_val.isdigit() or default_val in ['true', 'false']:\n                    constraints.append(f"DEFAULT {default_val}")\n                else:\n                    constraints.append(f"DEFAULT '{default_val}'")\n                    \n            schema.append({\n                "name": col_name,\n                "type": pg_type,\n                "constraints": " ".join(constraints)\n            })\n            \n        cursor.close()\n        conn.close()\n        return schema\n    except Exception as e:\n        print(f"Erro ao obter esquema da tabela {table_name}: {e}")\n        return []\n\ndef map_sqlite_to_pg_type(sqlite_type):\n    """Mapeia tipos SQLite para tipos PostgreSQL"""\n    sqlite_type = sqlite_type.upper()\n    if "INT" in sqlite_type:\n        return "INTEGER"\n    elif "CHAR" in sqlite_type or "TEXT" in sqlite_type or "CLOB" in sqlite_type:\n        return "TEXT"\n    elif "REAL" in sqlite_type or "FLOA" in sqlite_type or "DOUB" in sqlite_type:\n        return "FLOAT"\n    elif "BOOL" in sqlite_type:\n        return "BOOLEAN"\n    elif "BLOB" in sqlite_type:\n        return "BYTEA"\n    elif "DATE" in sqlite_type:\n        return "DATE"\n    elif "TIME" in sqlite_type:\n        if "TIMESTAMP" in sqlite_type:\n            return "TIMESTAMP"\n        return "TIME"\n    else:\n        return "TEXT"  # Tipo padrão\n\ndef create_pg_table(table_name, schema):\n    """Cria uma tabela no PostgreSQL"""\n    try:\n        conn = psycopg2.connect(PG_CONNECTION)\n        cursor = conn.cursor()\n        \n        # Construir a declaração CREATE TABLE\n        columns = [f"\"{col['name']}\" {col['type']} {col['constraints']}" for col in schema]\n        create_stmt = f"CREATE TABLE IF NOT EXISTS \"{table_name}\" ({', '.join(columns)});"\n        \n        print(f"Criando tabela {table_name}...")\n        cursor.execute(create_stmt)\n        conn.commit()\n        \n        cursor.close()\n        conn.close()\n        return True\n    except Exception as e:\n        print(f"Erro ao criar tabela {table_name} no PostgreSQL: {e}")\n        return False\n\ndef migrate_table_data(table_name):\n    """Migra dados de uma tabela SQLite para PostgreSQL"""\n    try:\n        # Conectar ao SQLite\n        sqlite_conn = sqlite3.connect(SQLITE_DB_PATH)\n        sqlite_cursor = sqlite_conn.cursor()\n        \n        # Obter dados da tabela SQLite\n        sqlite_cursor.execute(f"SELECT * FROM {table_name}")\n        rows = sqlite_cursor.fetchall()\n        \n        if not rows:\n            print(f"Tabela {table_name} está vazia. Nada para migrar.")\n            sqlite_cursor.close()\n            sqlite_conn.close()\n            return True\n        \n        # Obter nomes das colunas\n        sqlite_cursor.execute(f"PRAGMA table_info({table_name})")\n        columns = [col[1] for col in sqlite_cursor.fetchall()]\n        \n        # Conectar ao PostgreSQL\n        pg_conn = psycopg2.connect(PG_CONNECTION)\n        pg_cursor = pg_conn.cursor()\n        \n        # Limpar tabela PostgreSQL antes de inserir\n        pg_cursor.execute(f'TRUNCATE TABLE "{table_name}" RESTART IDENTITY CASCADE;')\n        \n        # Preparar declaração INSERT\n        placeholders = ", ".join(["%s"] * len(columns))\n        insert_stmt = f'INSERT INTO "{table_name}" ("{\"\, \"".join(columns)}") VALUES ({placeholders})'\n        \n        # Inserir dados em lotes\n        batch_size = 100\n        for i in range(0, len(rows), batch_size):\n            batch = rows[i:i+batch_size]\n            pg_cursor.executemany(insert_stmt, batch)\n            pg_conn.commit()\n            print(f"Migrados {min(i+batch_size, len(rows))}/{len(rows)} registros para {table_name}")\n        \n        sqlite_cursor.close()\n        sqlite_conn.close()\n        pg_cursor.close()\n        pg_conn.close()\n        \n        print(f"Migração de dados para {table_name} concluída com sucesso!")\n        return True\n    except Exception as e:\n        print(f"Erro ao migrar dados da tabela {table_name}: {e}")\n        return False\n\ndef main():\n    print("===== Iniciando migração de SQLite para PostgreSQL =====")\n    \n    # Verificar se o arquivo SQLite existe\n    if not os.path.exists(SQLITE_DB_PATH):\n        print(f"Erro: Banco de dados SQLite não encontrado em {SQLITE_DB_PATH}")\n        return False\n    \n    # Criar banco de dados PostgreSQL\n    if not create_postgres_db():\n        return False\n    \n    # Obter tabelas do SQLite\n    tables = get_sqlite_tables()\n    if not tables:\n        print("Nenhuma tabela encontrada no banco de dados SQLite.")\n        return False\n    \n    print(f"Encontradas {len(tables)} tabelas: {', '.join(tables)}")\n    \n    # Migrar cada tabela\n    for table in tables:\n        print(f"\nProcessando tabela: {table}")\n        schema = get_table_schema(table)\n        if not schema:\n            print(f"Erro ao obter esquema da tabela {table}. Pulando...")\n            continue\n        \n        if create_pg_table(table, schema):\n            migrate_table_data(table)\n    \n    print("\n===== Migração concluída! =====")\n    return True\n\nif __name__ == "__main__":\n    success = main()\n    sys.exit(0 if success else 1)\nEOF\n\nWrite-Host ""\nWrite-Host "===== Processo de configuração concluído com sucesso! ====="\nWrite-Host ""\nWrite-Host "Para completar a migração, execute os seguintes comandos:"\nWrite-Host ""\nWrite-Host "1. Instalar dependências:"\nWrite-Host "   cd $BASE_DIR/backend && pip install -r requirements.txt"\nWrite-Host ""\nWrite-Host "2. Migrar dados do SQLite para PostgreSQL:"\nWrite-Host "   cd $BASE_DIR && python scripts/migrate_sqlite_to_postgres.py"\nWrite-Host ""\nWrite-Host "3. Executar testes com cobertura:"\nWrite-Host "   cd $BASE_DIR/backend && ./scripts/run_tests_with_coverage.sh"\nWrite-Host ""\nWrite-Host "===== Fim do script ====="\n\n# Fim do script convertido\n

